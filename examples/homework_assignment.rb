require 'correlation_attack'
using CorrelationAttack::Refinements::Integer

# These bits should eventually equal the bits generated by a specific LFSR combinator
known_keystream = 0b1001011101110000110011000100010011010101110001011100001101001011

# These are the encrypted bits (starting at position 64 of the keystream)
encrypted_bits = 0b100000110101011000000010111000110101011101110001100101011000001100001111

# Setup LFSRs (mask is known, keys are unknown)
first_lfsr = CorrelationAttack::LinearFeedbackShiftRegister.new(12, 0b1000001010011)
second_lfsr = CorrelationAttack::LinearFeedbackShiftRegister.new(12, 0b1001000001101)
third_lfsr = CorrelationAttack::LinearFeedbackShiftRegister.new(12, 0b1000001101001)

# Guess keys of the correlated LFSRs
first_key = CorrelationAttack.guess_key(first_lfsr, known_keystream)
second_key = CorrelationAttack.guess_key(second_lfsr, known_keystream)

solved_first_lfsr = first_lfsr.reset(first_key)
solved_second_lfsr = second_lfsr.reset(second_key)

lfsr_combinator_function = ->(primary_bit, secondary_bit, tertiary_bit) {
  (primary_bit & (tertiary_bit ^ 1)) | (secondary_bit & tertiary_bit)
}

# Find the third key by supplying an LFSR combinator and trying each possible third key
third_key = CorrelationAttack.brute_force_key(third_lfsr, known_keystream) do |possible_third_lfsr|
  CorrelationAttack::LinearFeedbackShiftRegister::Combinator.build do
    add_lfsr solved_first_lfsr
    add_lfsr solved_second_lfsr
    # Supplied LFSR with the guessed key is added here
    add_lfsr possible_third_lfsr

    define_combinator_function(&lfsr_combinator_function)
  end
end

# Output the keys that were found
puts "Keys: " << [first_key, second_key, third_key].join(', ')

# Build the LFSR combinator using the solved keys
lfsr_combinator = CorrelationAttack::LinearFeedbackShiftRegister::Combinator.build do
  add_lfsr solved_first_lfsr
  add_lfsr solved_second_lfsr
  add_lfsr third_lfsr.reset(third_key)

  define_combinator_function(&lfsr_combinator_function)
end

# Setup a stream cipher that uses the LFSR combinator and skip the first 64 bits
stream_cipher = CorrelationAttack::StreamCipher.new(lfsr_combinator)
64.times { stream_cipher << 0; stream_cipher.read_bit }

# Feed the encrypted bits to the stream cipher
encrypted_bits.to_bit_array.each { |bit| stream_cipher << bit; }

# Read the decrypted bits from the stream cipher and output the plaintext
puts "Plaintext: " << 9.times.map { stream_cipher.read_byte.chr }.join
